# Проект "Ping-Pong через Kafka"

## Описание проекта

Проект представляет собой пример реализации взаимодействия двух микросервисов через Apache Kafka. В данном случае, один микросервис (API Gateway) отправляет сообщение в топик `ping`, а второй микросервис (`second-microservice`) читает это сообщение и отправляет ответ в топик `pong`. API Gateway ожидает ответа из топика `pong` и возвращает его клиенту.

### Архитектура проекта

1. **Zookeeper** — используется для управления кластером Kafka.
2. **Kafka** — брокер сообщений, который обрабатывает сообщения между микросервисами.
3. **API Gateway** — HTTP-сервер, который принимает запросы от клиента, отправляет их в Kafka и ждёт ответа.
4. **Second Microservice** — сервис, который читает сообщения из топика `ping`, обрабатывает их и отправляет ответ в топик `pong`.

---

## Запуск проекта

Для запуска проекта необходимо выполнить следующие шаги:

1. Убедитесь, что у вас установлен Docker и Docker Compose.
2. Склонируйте репозиторий с проектом.
3. Выполните команду:

   ```bash
   docker-compose up
   ```

4. После успешного запуска контейнеров, API Gateway будет доступен по адресу `http://localhost:3005`.

---

## Использование

### Swagger UI

Swagger UI доступен по адресу:

```
http://localhost:3005/swagger/index.html
```

### Пример запроса

Отправьте GET-запрос на эндпоинт `/ping`:

```bash
curl http://localhost:3005/ping
```

В ответ вы получите сообщение в формате JSON, например:

```json
{
  "message": "Ping Pong (some-uuid)"
}
```

---

## Особенности реализации

### wait-for-it.sh

В проекте используется скрипт `wait-for-it.sh`, который позволяет микросервисам дождаться полной готовности Kafka перед началом работы. Это важно, так как микросервисы зависят от Kafka для своей работы.

Исходный код скрипта можно найти в репозитории:  
[https://github.com/vishnubob/wait-for-it](https://github.com/vishnubob/wait-for-it)

Пример использования в Dockerfile:

```dockerfile
CMD ["./wait-for-it.sh", "kafka:9092", "--", "./main"]
```

---

## Проблемы и недостатки проекта

Этот проект похож на набор вредных советов по разработке микросервисов. Вот почему:

1. **API Gateway невозможно масштабировать**

   - API Gateway хранит состояние (каналы для ответов) в памяти. Если он упадёт или будет перезапущен, все ожидающие запросы будут потеряны. Это делает его ненадёжным и не подходит для масштабирования.

2. **Неправильное использование Kafka**

   - В Kafka ключи (поле `key`) используются для выбора партиций. Однако в этом проекте используется только одна партиция (`partition 0`), что делает невозможным масштабирование Kafka.
   - Для обработки сообщений следует использовать группы потребителей (consumer groups), но в данном проекте этого нет.

3. **Невозможность масштабирования второго микросервиса**

   - Второй микросервис (`second-microservice`) привязан к одной партиции (`partition 0`). Это означает, что даже если вы запустите несколько инстансов микросервиса, они не смогут параллельно обрабатывать сообщения, так как каждый инстанс будет конкурировать за одни и те же данные.

4. **Запрос-ответ через брокер — плохая практика**
   - Использование Kafka для реализации паттерна "запрос-ответ" считается дурной практикой. Брокеры сообщений предназначены для асинхронной обработки данных, когда точное время доставки и обработки не критично.
   - Если вам нужен синхронный ответ на запрос, лучше использовать балансировщик нагрузки (например, NGINX) и HTTP-запросы напрямую к сервисам.

---

## Рекомендации по улучшению

1. **Используйте HTTP для синхронных запросов**  
   Если вам нужно получить ответ на запрос, используйте HTTP-протокол и балансировщик нагрузки. Это позволит избежать сложностей, связанных с использованием Kafka для синхронного взаимодействия.

2. **Масштабируйте Kafka**

   - Добавьте больше партиций в топики, чтобы распределить нагрузку.
   - Используйте группы потребителей для параллельной обработки сообщений.

3. **Состояние в API Gateway**

   - Избегайте хранения состояния в памяти API Gateway. Вместо этого используйте внешнее хранилище (например, Redis) для хранения каналов ответов.

4. **Асинхронная обработка**
   - Пересмотрите архитектуру проекта. Если возможно, перейдите на полностью асинхронную модель обработки сообщений, где Kafka используется по назначению — для доставки сообщений "когда-нибудь".

---

## Заключение

Этот проект демонстрирует базовое взаимодействие микросервисов через Kafka, но содержит множество архитектурных недостатков. Он может быть полезен для обучения и понимания, как работает Kafka, но не рекомендуется для использования в реальных проектах без серьёзных доработок.
